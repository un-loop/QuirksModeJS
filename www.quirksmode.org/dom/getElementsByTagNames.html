<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html lang="en">
<!-- Mirrored from www.quirksmode.org/dom/getElementsByTagNames.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Sep 2017 17:30:09 GMT -->
<head><title>DOM extension - getElementsByTagNames</title><link rel="stylesheet" href="../quirksmode.css" /><link rel="up" href="contents.html" /><link rel="intro" href="intro.html" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="../quirksmode.js"></script><script type="text/javascript" src="usableforms.js"></script><script type="text/javascript"><!--function test1() {	var headerList = getElementsByTagNames('h1,h2,h3,h4');	showList(headerList);}function test2() {	var element = document.getElementById('test');	var formFieldList = getElementsByTagNames('input,select,textarea',element);	showList(formFieldList);}function showList(array) {	var writestring = '';	for (var i=0;i<array.length;i++) {		writestring += i + ': ' + array[i].nodeName + '\n';	}	alert(writestring);}// --></script></head><body bgcolor="#ffffff"><h2>getElementsByTagNames</h2><div id="header"></div><div class="floater"><p>A browser must support either <code>sourceIndex</code> or <code>compareDocumentPosition</code>to use this script to the fullest.</p><p>Safari 1.3.2 supports neither, so it doesn't order the elements.</p></div><p class="intro">HTML has several related elements with distinct tag names, like h1-h6 or input, select and textarea.<code>getElementsByTagName</code> works only on elements with the same tag name, so you cannot use it to geta list of all headers or all form fields.</p><p>The <code>getElementsByTagNames</code> script (note the plural "names") takes a list of tagnames and returns an array that contains all elements with these tag names <em>in the order they appear in thesource code</em>. This is extremely useful for, for instance, my <a href="toc.html">ToC script</a>, which needs all h3s andh4s in the document in the correct order.</p><p>I'd have loved to add this method to the Node prototype, but that's impossible in Explorer and Safari. ThereforeI use it as a normal function until all browsers expose their W3C DOM prototypes.</p><h3>Use</h3><p><code>getElementsByTagNames</code> takes two arguments:</p><ol>	<li>A string with a comma-separated list of tag names.</li>	<li>An optional start element. If it's present the script searches only for tags that are descendants	of this element, if it's absent the script searches the entire document.</li></ol><p>The function returns an array (and not a nodeList!) with the requested tags, ideally in the order they appearin the source code. For this sorting the browser must support either <code>sourceIndex</code> or<code>compareDocumentPosition</code>. If it supports neither (Safari) the array contains the elements in theorder of their tag names in the <code>getElementsByTagNames</code> call.</p><h4>Example 1</h4><pre>var headerList = getElementsByTagNames('h1,h2,h3,h4');</pre><p>Now <code>headerList</code> becomes an array with all h1-h4 tags in the document in order ofappearance. <a href="javascript:test1()">Run script</a>.</p><h4>Example 2</h4><pre>var element = document.getElementById('test');var formFieldList = getElementsByTagNames('input,select,textarea',element);</pre><p>Now <code>formFieldList</code> becomes an array with all form fields that are descendants ofthe element with ID="test" in order of appearance. <a href="javascript:test2()">Run script</a> onthis test form (correct answer: input, select, input, textarea).</p><div id="test"><form action="#">	<input name="name" /><br />	<select>		<option>Test select</option>	</select><br />	<input type="checkbox" /><br />	<textarea rows="5" cols="15"></textarea></form></div><h3>The script</h3><p>This is the script. Include it in your .js file and use it as described above.</p><pre>function getElementsByTagNames(list,obj) {	if (!obj) var obj = document;	var tagNames = list.split(',');	var resultArray = new Array();	for (var i=0;i&lt;tagNames.length;i++) {		var tags = obj.getElementsByTagName(tagNames[i]);		for (var j=0;j&lt;tags.length;j++) {			resultArray.push(tags[j]);		}	}	var testNode = resultArray[0];	if (!testNode) return [];	if (testNode.sourceIndex) {		resultArray.sort(function (a,b) {				return a.sourceIndex - b.sourceIndex;		});	}	else if (testNode.compareDocumentPosition) {		resultArray.sort(function (a,b) {				return 3 - (a.compareDocumentPosition(b) & 6);		});	}	return resultArray;}</pre><h3>Explanation</h3><pre>function getElementsByTagNames(list,obj){	if (!obj) var obj = document;</pre><p>First of all determine the start element: <code>obj</code>, or, if it's not given, the document.</p><pre>	var tagNames = list.split(',');	var resultArray = new Array();</pre><p>Split the list of tag names on commas. Create an array to hold the results.</p><pre>	for (var i=0;i&lt;tagNames.length;i++) {		var tags = obj.getElementsByTagName(tagNames[i]);		for (var j=0;j&lt;tags.length;j++) {			resultArray.push(tags[j]);		}	}</pre><p>Now we go through all tag names, use the normal <code>getElementByTagName()</code> to get all the elementswith one tag name, and transfer them to <code>resultArray</code> one by one. This is a bit of a kludge, butsince <code>getElementsByTagName</code> returns a nodeList, I cannot use <code>array.concat()</code> to createthe new array. Pushing the elements one by one is the best solution I've been able to find.</p><p>This gives us a <code>resultArray</code> with pointers to all elements with the desired tag names, but stillin the order the tag names had in the <code>getElementsByTagNames</code> call. We have to sort them in theirdocument order/</p><pre>	var testNode = resultArray[0];</pre><p>Now we start the sorting. We need to know if the browser supports <code>sourceIndex</code> or<code>compareDocumentPosition</code>, and to find out we take one node for a bit of support detection.</p><pre>	if (!testNode) return [];</pre><p>If there is no first node (ie. the page doesn't contain any of the requested elements), we return an emptyarray.</p><h4>Background: array.sort()</h4><p>The <code>array.sort()</code> method takes an optional function as an argument. This function compares two elements(usually called <code>a</code> and <code>b</code>). If the first one should go first the function shouldreturn a negative number, if the second one should go first, the function should return a positive number.</p><h4>sourceIndex</h4><p>If <code>sourceIndex</code> is supported, we sort the elements by comparing their sourceIndices.<code>sourceIndex</code> is a useful Microsoft extension that gives the source order number of an element. Thefirst element in the page (<code>&lt;html&gt;</code>) has <code>sourceIndex</code> 0, the second (<code>&lt;head&gt;</code>)has <code>sourceIndex</code> 1, etc. <code>sourceIndex</code> is also the index number of the element in<code>getElementsByTagName('*')</code>.</p><pre>	if (testNode.sourceIndex) {		resultArray.sort(function (a,b) {				return a.sourceIndex - b.sourceIndex;		});	}</pre><p>If we subtract the <code>sourceIndex</code> of the first element from that of the second, we get a negativenumber if the first element comes first, and a positive number if the last element comes first. This is exactlywhat <code>sort()</code> needs. <code>resultArray</code> now contains the elements sorted according to theirdocument position.</p><h4>compareDocumentPosition</h4><p>If <code>compareDocumentPosition</code> is supported, we sort the elements by using this method.<code>compareDocumentPosition</code> is a Level 3 Core method that compares the document position of two nodesand returns a bitmask:</p><ul>	<li>1: Position disconnected</li>	<li>2: Precedes</li>	<li>4: Follows</li>	<li>8: Contains</li>	<li>16: Is contained by</li></ul><p>If, for instance, a tag is contained by and follows another tag, <code>compareDocumentPosition</code> returns16 + 4 = 20.</p><pre>	else if (testNode.compareDocumentPosition) {		resultArray.sort(function (a,b) {				return 3 - (a.compareDocumentPosition(b) & 6);		});	}</pre><p>We're only interested in <code>compareDocumentPosition</code>'s values 2 or 4: precedes or follows. Thereforewe do a bitwise AND 6 (<code>& 6</code>) so that the result is 2 or 4 (of course it can't be 6: a node cannot bothprecede and follow another node).</p><p>If <code>b</code> follows <code>a</code>4 is returned, but <code>sort()</code> needs a negative number. If <code>b</code> precedes <code>a</code> 2 isreturned, but <code>sort()</code> needs a positive number. To give <code>sort()</code> what it needs I subtractthe 2 or 4 from 3. This gives 1 or -1, so that <code>sort()</code> now properly sorts the elements and<code>resultArray</code> contains the elements sorted according to their document position.</p><pre>	return resultArray;}</pre><p>Finally we return the <code>resultArray</code> to whichever function asked for it. Remember that if a browserdoesn't support either <code>sourceIndex</code> or <code>compareDocumentPosition</code> the array is not sorted.</p><div id="footer"><a href="https://www.quirksmode.org/home.html">Home</a> <a href="https://www.quirksmode.org/sitemap.html">Sitemap</a><p class="smaller" id="validation">Valid XHTML 1.0</p></div></body>
<!-- Mirrored from www.quirksmode.org/dom/getElementsByTagNames.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Sep 2017 17:30:10 GMT -->
</html>