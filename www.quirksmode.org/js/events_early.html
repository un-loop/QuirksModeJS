<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html lang="en">
<!-- Mirrored from www.quirksmode.org/js/events_early.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Sep 2017 17:29:50 GMT -->
<head><title>Javascript - Early event handlers</title><link rel="stylesheet" href="../quirksmode.css" /><link rel="up" href="contents.html" /><link rel="intro" href="introevents.html" /><link rel="prev" href="events_events.html" /><link rel="next" href="events_tradmod.html" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="../quirksmode.js"></script></head><body><h2>Early event handlers</h2><div id="header"></div><div class="floater"><p>See section 7B of <a href="https://www.quirksmode.org/book/">the book</a> for the default action.You should not use theinline event registration model any more.</p></div><p class="intro">On this page I explain the oldest way of adding event handlers, the way thatis even supported by the Version 2 browsers.</p><p>The oldest browsers support only one way of registering event handlers,the way invented by Netscape. There were no compatibility problems yet, Netscape called theshots and Microsoft had to follow its lead if it wished toproduce a browser that could handle JavaScript.Therefore this model works in all JavaScript browsers &#8212; exceptfor Explorer 3 on Mac, which doesn&#8217;t support events at all.</p><h3>Registering event handlers</h3><p>In the <em>inline event registration model</em>, event handlers areadded as attributes to the HTML elements they were working on, like:</p><pre>&lt;A HREF="somewhere.html" onClick="alert('I\'ve been clicked!')"&gt;</pre><p>When a click event takes place on the link, the event handler is invokedand executes the script: an alert is shown. You can also invoke a JavaScript function:</p><pre>&lt;A HREF="somewhere.html" onClick="doSomething()"&gt;</pre><p>The mix of upper and lower case in the event names (on<em>C</em>lick, on<em>M</em>ouse<em>O</em>ver) isonly a tradition. HTML is case insensitive, so you can use whatever case you like.In XHTML attribute names are all lower case, though, so if you use XHTML you must write <code>onclick</code>and <code>onmouseover</code>.</p><h4>Don't use it</h4><p>Although the inline event registration model is ancient and reliable, it has one seriousdrawback. It requires you to write JavaScript behavior code in your XHTML structure layer, whereit doesn't belong.</p><p>Therefore I strongly feel that you shouldn't use this model. See my<a href="http://www.digital-web.com/articles/separating_behavior_and_structure_2/"	class="external">Separating behavior and structure</a> column for the full argument.</p><p>Understanding this old model is necessary for a full overview of JavaScript event handling, butyou should use one of the modern models which I describe later on.</p><a name="default"></a><h3>Default action</h3><p>Back then Netscape also decided on default actions and how to prevent them.Its model has survived the intervening browser wars and standardizations, so that it still worksfine today.</p><p>As we all know, when the user clicks on a link the browser loads the pagespecified in its <code>href</code> attribute. This is the <em>default action</em> caused by a clickevent on a link. But what happens when you&#8217;ve also defined an <code>onclick</code>event handler? It should be executed, but when?</p><pre>&lt;A HREF="somewhere.html" onClick="doSomething()"&gt;</pre><p>In the case of a click on a link, the event handler <em>must</em> be executed first.After all, when the default action takes place &#8212;new page is loaded&#8212; the old page,including the event handler, is removed from browser memory. Therefore if the onclickevent handler is to be executed at all, it must be done <em>before</em> the default action.</p><p>This has become an important principle of event handling. If an event causes both a defaultaction and execution of a event handling script:</p><ol><li>the event handler script is executed first</li><li>the default action takes place afterwards</li></ol><p>So in our example the function <code>doSomething()</code> is executed first, only then doesthe browser follow the link.</p><h3>Prevent default</h3><p>When this was decided, people started thinking about <em>preventing</em>the default action. In our example it should be possible to prevent the browser from loadinga new page.</p><p>Therefore the event handler can <code>return</code> a boolean (true or false),and <code>false</code> means: &#8220;don&#8217;t take the default action&#8221;.So if we change our example to</p><pre>&lt;A HREF="somewhere.html" onClick="doSomething(); return false"&gt;</pre><p>the link is never followed. The function is executed and after that the event handler returns<code>false</code>, telling the browser not to take the default action.</p><p>It is also possible to let the function decide whether to allow the default action. Then wehave to change the example to</p><pre>&lt;A HREF="somewhere.html" onClick="return doSomething()"&gt;function doSomething(){	return confirm('Do you really want to follow this link?')}</pre><p>This is (very simple) user interaction. The user is asked a question; if he answers&#8217;OK&#8217; the function returns <code>true</code>, if he answers &#8217;Cancel&#8217; the function returns <code>false</code>.This returned value is caught by the event handler, which in turn returns it to the eventitself. If <code>false</code> is returned the default action is canceled &#8212; link is not followed.</p><p>However, you cannot prevent all default actions. An <code>unload</code>, for example, cannotbe prevented. Suppose the user closes the browser window &#8212; causing an <code>unload</code> eventin the page in the window. If you could prevent the unloading, would that mean the window staysopen regardless of the wishes of the user? No go.</p><p>You can try to stop the unloading with Microsoft&#8217;s proprietary <code>beforeunload</code>event. But even then the user is asked to confirm this prevention of the default action, creatinga very confusing situation. Better not to use it.</p><p>Returning false to prevent the default action works in all browsers, it&#8217;s a basic part ofevent handling. Modern event handling models have added some new ways of preventing the default:</p><ul><li>W3C has added the method <code>preventDefault()</code> to the event. If you callit the default action is prevented.</li><li>Microsoft has added the property <code>returnValue</code> to the event. If you set it to<code>false</code> the default action is prevented.</li></ul><p>But you don&#8217;t need to use them, a simple <code>return false</code> also does the job.</p><h4>window.status</h4><p class="vs0">There&#8217;s one exception to the <code>return false</code> rule. When you change the status text ofthe window after the user mouseovered a link, you also want to prevent the default action &#8212; show HREF in status bar.To do this you must return <code>true</code>:</p><pre>&lt;A HREF="somewhere.html"	onMouseOver="window.status = 'This link goes somewhere'; return true"&gt;</pre><p>If you don&#8217;t, the code will not work. Nobody knows why this is an exception, it&#8217;s just one ofthose strange things.</p><h3>this</h3><p>In JavaScript the <code>this</code> keyword always refers to the &#8220;owner&#8221; ofa function. In the case of event handlers it is very useful if <code>this</code> refers tothe HTML element the event is handled by, so that you have easy access to it.</p><p>Unfortunately the <code>this</code> keyword, though very powerful, is hard to use if you don&#8217;t knowexactly how it works. I discuss its use on<a href="this.html">another page</a>. Here I givea short summary of its use in the inline model.</p><p>In the inline model you can send <code>this</code> to the event handling function as anargument. So if you do</p><pre>&lt;A HREF="somewhere.html" onClick="doSomething(this)"&gt;function doSomething(obj){	// obj now refers to the link}</pre><p>you pass a reference to the link to the function, which stores it in <code>obj</code>.Now you don&#8217;t need to search the document to find the elementthe user clicked on: it is safely stored in <code>obj</code>. Now we can do:</p><pre>&lt;A HREF="somewhere.html" onClick="return doSomething(this)"&gt;&lt;A HREF="somewhereElse.html" onClick="return doSomething(this)"&gt;function doSomething(obj){	var linkTo = obj.href;	return confirm('Do you really want to follow the link to ' + linkTo + '?')}</pre><p>The function receives a reference to the link in the variable <code>obj</code>. You can now read out its<code>href</code> property and use it in the confirm. The trick is that you can add this eventhandling function to any link in the document: it will always report the href of the actuallink that has been clicked on.</p><h3>Continue</h3><p>If you wish to go through all event pages in order, you should now continue with the<a href="events_tradmod.html">Traditional event registration model</a> page.</p><div id="footer"><a href="https://www.quirksmode.org/home.html">Home</a> <a href="https://www.quirksmode.org/sitemap.html">Sitemap</a><p class="smaller" id="validation">Valid XHTML 1.0</p></div></body>
<!-- Mirrored from www.quirksmode.org/js/events_early.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Sep 2017 17:29:50 GMT -->
</html>