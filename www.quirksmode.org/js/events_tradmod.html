<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html lang="en">
<!-- Mirrored from www.quirksmode.org/js/events_tradmod.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Sep 2017 17:29:50 GMT -->
<head><title>Javascript - Traditional event registration model</title><link rel="stylesheet" href="../quirksmode.css" /><link rel="up" href="contents.html" /><link rel="intro" href="introevents.html" /><link rel="prev" href="events_early.html" /><link rel="next" href="events_advanced.html" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="../quirksmode.js"></script></head><body><h2>Traditional event registration model</h2><div id="header"></div><div class="floater"><p>See section 7C of <a href="https://www.quirksmode.org/book/">the book</a>.</p></div><p class="intro">On this page I explain the best way to register event handlers to an element,that is: to make sure a certain script runs when a certain event takes place on a certainHTML element.</p><p>In the oldest JavaScript browsers event registration was only possible through the<a href="events_early.html">inline model</a>.Since DHTML radically changed the way you could manipulate web pages, the event registration model had to be extendedand become more flexible. Therefore the browser vendors introduced new event models. Netscapealready started in Version 3, Explorer followed in Version 4.</p><p>Because Netscape 3 already supported the new registration model, it was a <em>de facto</em>standard before the Browser Wars.Therefore Microsoft was, for the last time, forced to implement this standard in order tokeep its browser compatible with uncounted Web pages using Netscape event handling.</p><p>So both browsers, and in fact all modern browsers, accept this code</p><pre>element.onclick = doSomething;</pre><p>as a correct way to register an event handler. Whenever the user clicks on the HTML element, thefunction <code>doSomething()</code> is executed.Because it is universally supported, because it is in fact the only way to registeran event handling function cross&#8211;browser,it&#8217;s very important that you thoroughly understand the possibilities and restrictionsof this model.</p><p>Since no official standard was available when this model was introduced, I call it the<em>traditional event registration model</em>.Meanwhile W3C has standardized event registration, and Microsoft has also createdan advanced model<span class="smaller">(see the <a href="events_advanced.html">Advanced models</a> page)</span>,but the traditional model still works fine.</p><h3>Advanced event registration</h3><p>From Netscape 3/Explorer 4 onwards, JavaScript recognizes a property for each sort of event that cantake place on an element. Therefore most HTML elements have the properties <code>onclick</code>, <code>onmouseover</code>,<code>onkeypress</code> etc. Which HTML elements have which properties&#8212; which HTML elements support which events &#8212;<a href="events_compinfo.html">depends</a> on the browser.</p><p>In themselves, these properties were not a radical novelty. They already existed in the oldest JavaScript browsers:</p><pre>&lt;a href="somewhere.html" onclick="doSomething()"&gt;</pre><p>Here the <code>A</code> tag has a <code>onclick</code> attribute, which in JavaScript becomesa property of the A element.In the oldest browser the event handler is only accessible through HTML attributes in the sourcecode of the page. So if you want this event handler on every link in your page you have tohard&#8211;code the function into every single A tag.</p><p>With the advent of the traditional event registration model, the<code>onclick</code>, <code>onmouseover</code> and all other event properties of the HTML elementare completely accessible throughJavaScript. Now you can add, change and remove event handlers without writing the slightest bit of HTML.After you have properly accessed the HTML element through a<a href="https://www.quirksmode.org/dom/intro.html">DOM</a>you can write your function into the property of your choice, like:</p><pre>element.onclick = doSomething;</pre><p>Now our example function <code>doSomething()</code> is registered to the <code>onclick</code> propertyof <code>element</code> and is therefore executed whenever the user clicks on the element.Note that the event name must be <em>all lower case</em>.</p><p>To remove the event handler, simply make the onclick method empty:</p><pre>element.onclick = null;</pre><p>The event handler is also a normal JavaScript function. It can beexecuted without an event taking place. If you do</p><pre>element.onclick()</pre><p><code>doSomething()</code> is executed. There&#8217;s no real event to go with it, though,so if your function expects one it doesn&#8217;t know what to do and produces errors.Therefore this way of executing event handlers is rarely useful.</p><p class="smaller"><a href="http://msdn.microsoft.com/library/default.asp?url=/workshop/author/dhtml/reference/methods/fireevent.asp"	 class="external">Microsoft</a> has added the <code>fireEvent()</code> methodto Explorer 5.5 and higher on Windows for the same purpose. The syntax is<code>element.fireEvent('onclick')</code></p><h4>No parentheses!</h4><p>Please note that in the registration of an event handler you do <em>not</em> use parentheses<code>()</code>.The <code>onclick</code> method expects to be assigned an entire function. If you&#8217;d do</p><pre class="wrong">element.onclick = doSomething();</pre><p>the function would be executed and its <em>result</em> would be registered toonclick. This is not what we want, we want the function to be executed when the event takes place.In addition the function has usually been written to expect an event and if we&#8217;d executeit without any such context it would get terribly confused and produce JavaScript errors.</p><p>Instead we <em>copy</em> the function <code>doSomething()</code> to the event handler in itsentirety. We do not execute it yet, that should only happen when the event actually takes place.</p><h3>this</h3><p>In JavaScript the <code>this</code> keyword always refers to the &#8220;owner&#8221; ofa function. In the case of event handlers it is very useful if <code>this</code> refers tothe HTML element the event is handled by, so that you have easy access to it.</p><p>Unfortunately the <code>this</code> keyword, though very powerful, is hard to use if you don&#8217;t knowexactly how it works. I discuss its use on<a href="this.html">another page</a>. Here I givea short summary of its use in the traditional model.</p><p>In the traditional model <code>this</code> works as follows; note that it works slightlydifferently than in the <a href="events_early.html">inline model</a>.Now the <code>this</code> keyword isin the function, not in the HTML attribute. The difference will be explained on a separate page.</p><pre>element.onclick = doSomething;another_element.onclick = doSomething;function doSomething() {	this.style.backgroundColor = '#cc0000';}</pre><p>If you register <code>doSomething()</code> as the <code>click</code> event handler of any HTML element,that element gets a red background whenever the user clicks on it. </p><h3>Anonymous functions</h3><p>Suppose you want to change the background color of all DIVs onmouseover and restore thecolor onmouseout. Using <code>this</code> correctly, you could do the following:</p><pre>var x = document.getElementsByTagName('DIV');for (var i=0;i&lt;x.length;i++) {	x[i].onmouseover = over;	x[i].onmouseout = out;}function over() {	this.style.backgroundColor='#cc0000'}function out() {	this.style.backgroundColor='#ffffff'}</pre><p>This code will work, no problem.But since the functions <code>over()</code> and <code>out()</code> are so simple,it is much more elegant to register them as <em>anonymous functions</em>:</p><pre>...for (var i=0;i&lt;x.length;i++) {	x[i].onmouseover = function () {this.style.backgroundColor='#cc0000'}	x[i].onmouseout = function () {this.style.backgroundColor='#ffffff'}}</pre><p>The <code>onmouseover</code> and <code>onmouseout</code> properties expect a function anyway.Instead of copying <code>over()</code> and <code>out()</code>, we immediatelydefine the event handling function in the event handling registration script. Since thesefunction do not have a name, they are <em>anonymous</em>.</p><p>The two ways of registering event handlers are completely the same, the only difference isthat the second one clutters your code less. I very much like anonymous functions and usethem whenever I want to register a simple event handler.</p><h3>Problems</h3><p class="vs0">A distinct drawback of the traditional model is that the <code>onclick</code> propertycan contain only one function. This becomes a problem when you want to register multiple eventhandlers for one event.</p><p>For instance, suppose you&#8217;ve written a module that makes it possible to drag and drop a layer.The module registers an onclick event handler to an element so that clicking on it starts the drag and drop.You have also written a module that silently keep track of user clicks and sends this informationto the server <code>onunload</code>, so you can find out how your pages are used.This module, too, registers an onclick event handler to an element.</p><p>So what you&#8217;d really like to do is</p><pre>element.onclick = startDragDrop;element.onclick = spyOnUser;</pre><p>However, it&#8217;s here that things start to go wrong. The second registration of a function to<code>onclick</code> overwrites the first one so that only <code>spyOnUser()</code> is executed when theuser clicks on the element.</p><p>The solution is of course to register a function that executes both other functions:</p><pre>element.onclick = function () {startDragDrop(); spyOnUser()}</pre><h3>Flexible registration</h3><p>But suppose that you don&#8217;t use both modules on every page in your site.Now if you&#8217;d do</p><pre>element.onclick = function () {startDragDrop(); spyOnUser()}</pre><p>you could get error messages because one of the two functions might be undefined.So you have to be more careful in registering your event handlers.When we want to register <code>spyOnUser()</code> while <code>startDragDrop()</code> may(or may not) be registered, we do:</p><pre>var old = (element.onclick) ? element.onclick : function () {};element.onclick = function () {old(); spyOnUser()};</pre><p>First you define a variable <code>old</code>. If the element currently has an onclick event handler,put this event handler in <code>old</code>, if it hasn&#8217;t, put an empty function in <code>old</code>.Now you register a new event handler to element <code>div</code>. It is a function that first executes<code>old()</code> and afterwards <code>spyOnUser()</code>.<br />Now the new event handler is added to the element, while previously registered handlers (if any) arepreserved.</p><p>One last problem: What if you want to remove one of the event handlers,but not the other? At the moment I&#8217;m not sure how this should be done. You&#8217;d have toedit <code>element.onclick</code> in some way, but I haven&#8217;t really studiedthis problem.</p><h3>Other models</h3><p>So we have seen that the traditional event registration model is simple to use, but has somenasty problems as soon as you want to add more than one event handler to the same event on thesame element.The W3C event registration model solves this problem quite neatly.</p><h3>Continue</h3><p>If you wish to go through all event pages in order, you should now continue with the<a href="events_advanced.html">Advanced models</a> page.</p><div id="footer"><a href="https://www.quirksmode.org/home.html">Home</a> <a href="https://www.quirksmode.org/sitemap.html">Sitemap</a><p class="smaller" id="validation">Valid XHTML 1.0</p></div></body>
<!-- Mirrored from www.quirksmode.org/js/events_tradmod.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Sep 2017 17:29:50 GMT -->
</html>